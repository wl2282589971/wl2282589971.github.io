<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yuunawl.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yuunawl.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-音音の杂谈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/11/%E9%9F%B3%E9%9F%B3%E3%81%AE%E6%9D%82%E8%B0%88/" class="article-date">
  <time datetime="2020-12-11T00:37:00.000Z" itemprop="datePublished">2020-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/11/%E9%9F%B3%E9%9F%B3%E3%81%AE%E6%9D%82%E8%B0%88/">音音の杂谈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h3 id="2020-12-8"><a href="#2020-12-8" class="headerlink" title="2020.12.8"></a>2020.12.8</h3><p>熟悉我的人都知道，这一学期让我改变了很多。</p>
<p>在此之前，包括高中和大学的前三年，我一直都是一个比较内向的人。但这内向带来的恶果，在上一学期爆发了。一方面，因为考研和直接工作的抉择。另一方面，因为内向，而没有尝试向别人倾诉（包括我的父母）。随之而来的结果，我可能陷入了忧郁之中。现在回想起来还是感觉可怕，那段时间，毫无作息而言，不知道想做什么，一味地把自己埋在小说、漫画和睡觉中来逃脱现实。所谓的绝望，大抵如此。</p>
<p>好在这学期开始，下定决心放弃考研，迈入社会的我，更加积极地参与学校的实践，不再像之前一样划水摸鱼，也开始尝试和他人进行沟通，包括父母、亲人、同学和老师。怎么说呢，逐渐找回了小时候那个阳光的自己。让我回想起来，曾经是想要成为一个像太阳一样，能够给他人带来笑容和光芒的人。</p>
<p>如果大家有什么烦恼需要倾诉，我觉得我会是一个很好地聆听者。</p>
<h3 id="2020-12-9"><a href="#2020-12-9" class="headerlink" title="2020.12.9"></a>2020.12.9</h3><p><strong>为什么自称音音：</strong></p>
<p>扩列，扩列</p>
<p>FF14 拉诺西亚 宫永音音(Miyanaga Nene)，曾用名Luciia，主职绝枪战士，也玩骑士、DK、召唤和忍者。零式摸鱼选手。</p>
<p>最开始是FF14开黑打本的时候自称音音酱，目的是恶心人。结果叫着叫着习惯了，现在就经常这么自称，可能是现在脸皮厚了。</p>
<p><strong>音音的人生理想：</strong></p>
<p>作为一条正宗咸鱼，我的人生理想是能从事自己喜欢的工作，爱一个自己喜欢的人，一个月能氪2单648，新出的单机能立马上手。</p>
<p><strong>音音的世界观：</strong>哲学意义上，我的世界观更偏向主观唯心主义，这可能也是我迟迟没有入党的原因之一。观念上更加认同道家的思想，像“道法自然”，“清静无为”，“逍遥”，“天地与我并生，而万物与我为一”这样的思想。为人处世上以个人意愿作为最高准则（不包括现实利益），像是高考选择上，按照一般观念，浙江人，分数能上浙大，基本都会首先考虑浙大。但当时我基本只对信息和心理感兴趣，心理学被家长直接毙了，只剩下信息。所以高考志愿填报清一色地填了信息。那年是浙江高考改革的第一年，按专业录取，能填80个专业，我应该是填了50多个信息专业。第一二三个填了浙大创新平台，信息和新媒体，之后就是北航的信息大类，最后和浙大信息差了两分。如果考虑浙大的话，除了信息，新媒体，理科，自动化以及一些实验班之外，应该都能被录取。不过对于这一选择，我还是比较满意的，至少像机械与能源这样的专业，本科毕业，还是比较难找好工作的。</p>
<p><strong>之后的发展：</strong>工作地点应该主要是北京和杭州，上海也是选择之一。当然长期考虑的话杭州更好，毕竟北京的房价太为难人了。其实是想看女朋友在哪，选择在哪工作。所以其实这最大的问题是，我没有女朋友……给点作用啊，音音酱。</p>
<h3 id="2020-12-11"><a href="#2020-12-11" class="headerlink" title="2020.12.11"></a>2020.12.11</h3><p><strong>音音的消费观：</strong>自由消费，当然自由消费是建立在兜底的情况下。所以暂定每月收入的一半存储下来，一半用于消费，当然目前对于北京的房价还没有清晰的认知，这比例也会随之调整。</p>
<p><strong>为什么不考研：</strong></p>
<p>三方面的原因。</p>
<p>一是不好考，21系总共166名学生，不包括高工和北院，总共的研究生名额就20个左右，去除保研的名额，基本只剩下个位数，目前已知的报录比基本是二三十比一，竞争相当激烈。如果选择报考6系，虽然竞争压力下降，报录比差不多六比一，但要学习6系的计组，操作系统和计网等，而6系的这些课程，比21系难得多。</p>
<p>二是不想考，我本人就是不太喜欢科研的人，比起研究深度神经网络，各种数据模型，算法结构，测试方法，我更喜欢在公司参与产品的开发和运营，这能给我带来更大的成就感。</p>
<p>三是没必要考，软件工程专业，即使本科毕业，就业压力也不大，其实每年21系都有不少学生本科毕业直接参与工作，其比例高出北航的平均，甚至包括一些差点保研的学生。在就业方面，虽然学历同样很重要，比如本科毕业基本只能参与前后端开发，例如算法架构这样的职位一般都要硕士及以上，但学历的比重没有那么高，项目和工作经历在某种意义上更加重要，尤其是对于产品经理和游戏策划或者运营这些业务型而不是技术型的互联网岗位。其次，本科毕业的薪金也不低，以我目前准备的游戏策划为例，中型游戏公司（指3-4款产品在运营）的月薪12K-20K，1大型游戏公司（猪鹅米哈游这样的）月薪15K-25K，足够满足我的日常生活，即使是在生活压力很大的北京或者上海。</p>
<h3 id="2020-12-12"><a href="#2020-12-12" class="headerlink" title="2020.12.12"></a>2020.12.12</h3><p><strong>音音今天干啥：</strong>上午画毕设流程图，原型图，修改开题报告。下午去公司开毕设周会，之后修改简历，写游戏设计草案。晚上FF14刷龙，刷妖表fate。</p>
<h3 id="2020-12-13"><a href="#2020-12-13" class="headerlink" title="2020.12.13"></a>2020.12.13</h3><p><strong>音音今天干啥：</strong>准备开题，把开题报告第二版整完，做完开题PPT，然后询问导师意见，并约好评审表签字时间。有空的话谢谢游戏设计草案。</p>
<p><strong>游戏对我意味着什么：</strong>马斯洛认为，人的需要有生理的需要、安全的需要、归属与爱的需要、尊重的需要、自我实现的需要五个等级构成。游戏的存在主要是为了满足归属和爱的需求、尊重的需求和自我实现的需求。有些人在真实生活中比较自闭，不敢与人交流，但在游戏的世界中却能正常社交，这是满足归属于爱的需求。有些人在游戏中通过肝、氪或者出人的游戏理解，成为他人眼中的大佬，这是满足尊重的需求。也有人仅仅是享受着游戏这个提供第二个世界的艺术本身，其享受的是自我实现的价值。</p>
<p>对于我而言，这三者都存在。作为一个现实中有少许内向的人，游戏为我提供了社交的另一种途径，同时，通过游戏中的社交，我也认识了现实中很多nice的人，空余时间我们也常一起聚会，玩玩桌游或者线下开黑，不知不觉，游戏已经成了我日常生活难以割舍的一部分。</p>
<p>另一方面，除了社交之外，我在游戏中追求的就是极致的塔诺西(乐趣)，我很少玩PVP的一个原因就是我不想在游戏中寻求竞争而产生的快感，更享受的是RPG类游戏的沉浸时体验。因为如此，我很少有一款游戏能玩很久，因为再好的游戏，当他的内容被我所了解后，我便不会再去体验相似的二周目或者三周目。手游玩得旧的倒是有，但基本属于咸鱼状态，例如FGO，我算是开服玩家（ios玩了一年，之后玩的安卓）从一开始每个活动爆肝，到现在甚至懒得签到和推主线，或许之后我会继续玩这些游戏，但当初的乐趣已经不再，这也是为什么游戏如此快不断涌现的原因，人们需要新的游戏在提供这样的新鲜感和乐趣。</p>
<p>对于我个人，游戏也是填补我空虚的方式之一，作为一个基本没有爱好和特长的人，我的空闲时间基本就是被游戏、动漫和小说占据。</p>
<p><strong>感情经历：</strong>我的感情经历比较简单，大概是从很久很久之前，就喜欢着一个人，久到超过我目前人生的一半，因为这份过早的爱恋，不敢表达自我。这可能也是我从小时候的阳光到后来逐渐内向的原因之一。在随后的人生中，逐渐也认识了很多人，但也抹不去最初的痕迹，就像倒影一样，映在心海之上。</p>
<p>大学时期，尝试过一段情感，但终究是无法真正爱上另一个人而选择了和平分手，对方是很好的人，但我却不是那个成熟到能接受这份感情的人，这可能就是青涩的过错吧。</p>
<p>那这段已经久到不知从何开始的感情，是翻转新的篇章的逗号，还是迎来结束的句号，或许马上就要迎来答案。在青春即将结束的现在，尝试着去面对自己的内心吧，即使是失败，这份直面自我的决心也是没有错的吧。无论结果如何，仅仅是希望去传达这份声音。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/12/11/%E9%9F%B3%E9%9F%B3%E3%81%AE%E6%9D%82%E8%B0%88/" data-id="ckijjkuz20000q8u3bt38f2kh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-音音の面经" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/09/%E9%9F%B3%E9%9F%B3%E3%81%AE%E9%9D%A2%E7%BB%8F/" class="article-date">
  <time datetime="2020-12-08T23:55:08.000Z" itemprop="datePublished">2020-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/09/%E9%9F%B3%E9%9F%B3%E3%81%AE%E9%9D%A2%E7%BB%8F/">音音の面经</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<p><strong>写在前面：</strong></p>
<p><strong>关于我如何进行职业选择</strong>：经过两个月的面试，自己的职业选择也逐渐清晰。最早考虑的还是技术岗，上学期一开始准备的是Java后端开发，但确实上学期的学习状态不佳。后来转向前端开发，一方面自己在学校的项目中也是主要负责前端部分，但实际面试中发现，自己只能拧螺丝，不能造火箭。因为自己的前端开发，包括JS基本都是根据项目实际开发的需要学习的，比如Vue框架，Element组件，Ajax等等，所以并没有系统学习过JS和源生的Node.js，让我参与实际的项目开发可以，但让我用JS写快速排序，node.js的基础，E6S新特性，DOM域渲染之类的，基本都是回答出来的。</p>
<p>后面就考虑国企、公务员之类的，也去了解了一下选调，但选调的地点都比较远——哈尔滨、盐城这样的，最后也没有参加，另一方面，自己也不想过早进入养老生活，还是想做有追求的工作。最后想想自己有什么长处，好像就游戏玩的比较多，然后稍微了解了下游戏策划，就直接去面试了。</p>
<h3 id="面试汇总"><a href="#面试汇总" class="headerlink" title="面试汇总:"></a>面试汇总:</h3><p>首先是显而易见的几个点：礼貌、心态和诚实。</p>
<p><strong>礼貌：</strong>面试过程中尽量面带笑容，面试开始时说您好，在面试官回答完你的问题是，记得说谢谢。</p>
<p><strong>心态：</strong>虽然是打工人，但应聘本来就是一种双向选择，在这一层次上，应聘者与公司应当处于同等地位，至少我这样认为。所以面试的时候不需要低声下气，尽量将自己平时的说话表达展现出来，展示自己的自信与阳光。在被问到期望薪金的时候，也不需要刻意地退让。</p>
<p><strong>诚实：</strong>个人认为是最需要注意的点。我们常说要包装简历，包装自己，实质是让自己的简历更有吸引力。对于这一点，我本人没有采用，但也不反对。不过注意，简历包装需要适度，对于学历，学校这些硬性指标，必须如实填写。而且简历中的项目或者实习经历，大概率会在之后的面试中被问到。</p>
<p><strong>要点1：职业规划</strong></p>
<p>首先要了解面试官像从你的职业规划中了解到什么？</p>
<p>1.对应聘岗位是否熟悉，以游戏策划为例，详细分的话，游戏策划助理-游戏策划-资深游戏策划-游戏总策划-游戏制作人，大致是这样的。</p>
<p>2.有明确职业规划的人相对来说更加优秀，这说明他们以后在事业中，也会有相对清晰的规划。</p>
<p>我的大致规划，第一至二份工作地点选择在北京、或者杭州，上海也可以考虑（即职业前8年左右）。再之后根据家庭因素在进行考虑。</p>
<h3 id="专利审查中心北京中心："><a href="#专利审查中心北京中心：" class="headerlink" title="专利审查中心北京中心："></a>专利审查中心北京中心：</h3><p><strong>进度：</strong>凉凉</p>
<p><strong>简评：</strong>专利审查中心属于事业单位，待遇包括薪酬都十分不错。</p>
<p>老实说我都不知道自己怎么通过简历筛选的，这个岗位明确写了硕士及以上学历，问的专业问题挺基础的，但我没准备这方面的内容，答得不流畅。一个是关于计算机寻址的，一个是关于高速缓存的。</p>
<h3 id="字节跳动游戏策划实习生："><a href="#字节跳动游戏策划实习生：" class="headerlink" title="字节跳动游戏策划实习生："></a>字节跳动游戏策划实习生：</h3><p><strong>进度：</strong>凉凉</p>
<p><strong>简评：</strong>字节的面试怎么说呢，整体就不怎么舒服。倒不是因为面试卡壳了，而是字节的面试更像是再召一个产品经理，而不是游戏策划。包括从面试中，也很难感觉到面试官对游戏的热爱。在加上字节可怕的企业文化。这波啊，不是字节把我ban了，是我把字节ban了。</p>
<p><strong>具体面试内容</strong>:</p>
<p><strong>1.职业规划：</strong>详见汇总</p>
<p><strong>2.知道什么和游戏的指标</strong>：</p>
<p>没提前准备，回答了买量、日活、月活、流水</p>
<p><strong>3.从2延伸，问了日活的计算：</strong></p>
<p>不同游戏的日活计算方法可能不同。</p>
<p>有的可能是算登录日期，有的是算下线日期。（持续时间不超过一天），有的根据游戏时长在哪一天占比更高，例如，一款游戏从昨天晚上10点玩到今天凌晨4点，那么游戏时长在今天的占比更高，所以算入今天的日活计算。</p>
<h3 id="Topjoy游戏系统策划："><a href="#Topjoy游戏系统策划：" class="headerlink" title="Topjoy游戏系统策划："></a>Topjoy游戏系统策划：</h3><p>施工中</p>
<h3 id="国家电网通用航空公司："><a href="#国家电网通用航空公司：" class="headerlink" title="国家电网通用航空公司："></a>国家电网通用航空公司：</h3><p>施工中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/12/09/%E9%9F%B3%E9%9F%B3%E3%81%AE%E9%9D%A2%E7%BB%8F/" data-id="ckignr34u00013wu30mrs3sp4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-创之轨迹简评" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/08/%E5%88%9B%E4%B9%8B%E8%BD%A8%E8%BF%B9%E7%AE%80%E8%AF%84/" class="article-date">
  <time datetime="2020-12-08T05:54:16.000Z" itemprop="datePublished">2020-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/08/%E5%88%9B%E4%B9%8B%E8%BD%A8%E8%BF%B9%E7%AE%80%E8%AF%84/">音音の游戏简评——创之轨迹</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h5><p>作为轨迹从帝国篇过渡到共和国篇的带有外传性质的过渡之作，创之轨迹无疑给我带来了很大的惊喜，无论从战斗，还是最为主要的剧情，包括通关主线之后的玩法上，让我回想起了最初游玩轨迹系列的那份感动。</p>
<p>(懒得从PS4搬图，所以没有图，以及以下可能含有剧透)</p>
<h3 id="战斗："><a href="#战斗：" class="headerlink" title="战斗："></a>战斗：</h3><p>创轨基本延续了闪4的战斗系统，slot从闪4的2条变成了3条，珠子的稀有度也随之增加。核心回路的数量大幅度增加，虽然很多特效差不多，就是换了个系。</p>
<p>主要增加了英勇狂怒的战斗系统，将前作基本没用的奇袭点数利用起来，在进行物理、魔法、治疗的同时还能恢复3点BP(划重点)。在游戏后期，配置了恢复奇袭点数的珠子之后，配合英勇狂怒基本能保证每次战斗都能开阵，就算是5BP的也行。</p>
<p>以我噩梦一周目阵容为例：克洛+二姐+斯文+小约</p>
<p>噩梦+100级情况下，用二姐阵+魔法增幅4+克洛BUFF+白银狼或者失落创世纪依旧能秒大多数BOSS，伤害基本200W左右。</p>
<p>斯文和小约全堆速度和奇袭点数恢复，用英勇狂怒回BP。</p>
<h3 id="人物塑造："><a href="#人物塑造：" class="headerlink" title="人物塑造："></a>人物塑造：</h3><p>个人认为除了新出的拉碧丝，3和9外，创轨主要塑造的就是三条线的主角：罗伊德、黎恩和卢法斯。</p>
<p>其中罗伊德的人物形象在零碧中已经塑造的相当饱满，以下就简单谈谈黎爷和大少。</p>
<h5 id="黎恩："><a href="#黎恩：" class="headerlink" title="黎恩："></a>黎恩：</h5><p>黎爷是那种很标准的英雄模板人物，温柔、乐于助人，愿意牺牲自己拯救世界，另一方面面对感情和自己却显得优柔寡断。无法否认的是黎爷的人物设计确实很帅，包括造型，衣着，战技，S技，当然最帅的还是各种神气合一，但抛开这些造型，黎爷的人物其实是有点空洞的，从闪1到闪4，很难感受到黎爷有什么成长，一如既往是那个遇到危险，愿意牺牲自己，拯救同伴和世界的人。</p>
<p>但在创轨中，我看到了他的成长。</p>
<p>在遇见另一个世界线的自己，知晓了本可能的道路时。面对BE黎牺牲自我，拯救世界的道路，他说出了不。简简单单的否决，却让我看到了他那在英雄的光辉中渐渐浮现出来的人性。他学会了自爱，或者说，他为了周围爱他的人，学会了自爱。这一刻，他就不再是闪轨中那个有点模板化的“灰之英雄”，而是真正的黎恩·舒华泽。</p>
<p>同样的选择，我想起了FSN里的卫宫士郎和红A。红A沿着切嗣的梦想，成为了一个杀死少数人，拯救大多数的正义的英雄，但过于执着于这份理想的不自爱，让他渐渐迷失，只是一味成为抑制力的工具，无论生前还是死后。而士郎，在本篇的3条线中，均不会成为红A。Fate线后，在与少女骑士邂逅之后，虽然最后离别，但抱着那份恋情，他学会了自爱。UBW线中，与凛的亲密关系使得他虽然在时钟塔后大概率和红A线中一样游历世界，却因为对高岭之花的爱而不会成为孤独的英雄。HF更是把个人的爱与理想的冲突演绎到了极点，是正义的伙伴，还是成为那个人的唯一，在这样的矛盾中，他也做出了自己的选择。</p>
<p>创轨的结局就是把黎爷置于如此的矛盾之下，用这样的矛盾，将黎爷的人性彻底立了起来。</p>
<p><strong>卢法斯(C):</strong></p>
<p>施工中……</p>
<h3 id="剧情："><a href="#剧情：" class="headerlink" title="剧情："></a>剧情：</h3><p><strong>简评：</strong>创轨的剧情为线性推进，三条线：罗伊德、黎恩和C。</p>
<p>罗伊德线：严格意义上罗伊德算是创之轨迹的主角，从PV站中间位也能看出，同时舞台搭建在克洛斯贝尔，本应是罗伊德展现风采的时刻。但可惜的是，罗伊德线有点虎头蛇尾，除了开头的克洛斯贝尔保卫战还能让我感觉些许热血外，其余剧情或多或少有点牵强且无聊。</p>
<p>黎恩线：稳中有闪光点，前期在帝都与C等人的交锋，中期在诺尔德高原的对战，都属于虽然称不上优秀，但不无聊的剧情。而当在诺尔德中零之骑神登场，和镜之城中BE黎恩的登场则是将黎恩线带入了高潮。不同的世界线，不同的命运，正确与否也随之拉开序幕。</p>
<p>C线：C线是在创轨中最让我感到惊喜的部分，falcom少有地采用了诙谐的叙事，拉碧丝和娜酱负责搞笑，斯文担当吐槽役，C表示负责帅就够了。整体剧情就在诙谐的氛围中渐渐拉开了这场事变的最终黑幕，整体的剧情体验相当好，新角色，3和9，拉碧丝的塑造也不错。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/12/08/%E5%88%9B%E4%B9%8B%E8%BD%A8%E8%BF%B9%E7%AE%80%E8%AF%84/" data-id="ckib3m39e0000dou340856002" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-音音のFF14-5-4技改" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/08/%E9%9F%B3%E9%9F%B3%E3%81%AEFF14-5-4%E6%8A%80%E6%94%B9/" class="article-date">
  <time datetime="2020-12-08T00:23:49.000Z" itemprop="datePublished">2020-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/08/%E9%9F%B3%E9%9F%B3%E3%81%AEFF14-5-4%E6%8A%80%E6%94%B9/">音音のFF14---5.4技改</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自B站艾路雷朵</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv8712969">https://www.bilibili.com/read/cv8712969</a></p>
<p><img src="https://i0.hdslb.com/bfs/article/watermark/1564f0df1b97470e8126762bfeb4d727d5174be4.png" alt="img"></p>
<p>结论：和我天下无敌的绝枪战士没什么关系。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/12/08/%E9%9F%B3%E9%9F%B3%E3%81%AEFF14-5-4%E6%8A%80%E6%94%B9/" data-id="ckif8w6b10000s0u394zo1enw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-音音の座右铭" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/07/%E9%9F%B3%E9%9F%B3%E3%81%AE%E5%BA%A7%E5%8F%B3%E9%93%AD/" class="article-date">
  <time datetime="2020-12-06T23:23:13.000Z" itemprop="datePublished">2020-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/07/%E9%9F%B3%E9%9F%B3%E3%81%AE%E5%BA%A7%E5%8F%B3%E9%93%AD/">音音の座右铭</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="せめてこの夜に誓って"><a href="#せめてこの夜に誓って" class="headerlink" title="せめてこの夜に誓って"></a>せめてこの夜に誓って</h1><p><strong>出处</strong>：闪之轨迹4前夜谈BGM名称</p>
<p><strong>翻译</strong>：至少对今夜起誓</p>
<p><strong>网易云播放地址</strong>：<a target="_blank" rel="noopener" href="https://music.163.com/#/song?id=1333128232">https://music.163.com/#/song?id=1333128232</a></p>
<p><strong>简述</strong>：无法知晓明天会迎来如何结局的少年，选择在这个夜晚直面自己的内心，无论未来如何，至少今夜会成为一段永恒的回忆。</p>
<p><strong>我的理解</strong>：生活的锚点，是在过去、现在、还是未来。总被要求规划未来，但那样的生活，不会感觉无聊么？人生的波澜壮阔，不就在于那如无垠星空般的可能性么。当过去已成记忆中的泡影，当未来还笼罩在迷雾中。我所能做的，就是现在，直面自己的内心，去承认自己一切的悲伤、一切的痛苦，以及一切的爱。望着天上的夜空，在这个夜晚，至少，至少让我对自己起誓，去成为那个所要成为的人。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/12/07/%E9%9F%B3%E9%9F%B3%E3%81%AE%E5%BA%A7%E5%8F%B3%E9%93%AD/" data-id="ckidrv3eg0000hsu35qy9a5cv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据可视化入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/06/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2020-10-06T08:19:07.000Z" itemprop="datePublished">2020-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/06/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%A5%E9%97%A8/">数据可视化入门01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="切片函数"><a href="#切片函数" class="headerlink" title="切片函数"></a>切片函数</h5><p>python的数组索引方法</p>
<p>A[x:y:z]</p>
<ul>
<li>x代表索引的开始地址，可以为负数，代表倒数第几个数，默认为0</li>
<li>y代表到哪个索引 为止，同样可以为负数，默认为0</li>
<li>z代表每个几个元素选取，默认为1</li>
</ul>
<h5 id="numpy对象"><a href="#numpy对象" class="headerlink" title="numpy对象"></a>numpy对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(object, dtype &#x3D; None, copy &#x3D; True, order &#x3D; None, subok &#x3D; False, ndmin &#x3D; 0)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">object</td>
<td align="left">数组或嵌套的数列</td>
</tr>
<tr>
<td align="left">dtype</td>
<td align="left">数组元素的数据类型，可选</td>
</tr>
<tr>
<td align="left">copy</td>
<td align="left">对象是否需要复制，可选</td>
</tr>
<tr>
<td align="left">order</td>
<td align="left">创建数组的样式，C为行方向，F为列方向，A为任意方向（默认）</td>
</tr>
<tr>
<td align="left">subok</td>
<td align="left">默认返回一个与基类类型一致的数组</td>
</tr>
<tr>
<td align="left">ndmin</td>
<td align="left">指定生成数组的最小维度</td>
</tr>
</tbody></table>
<h5 id="dtype"><a href="#dtype" class="headerlink" title="dtype"></a>dtype</h5><ul>
<li>基本数据类型</li>
</ul>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bool_</td>
<td align="left">布尔型数据类型（True 或者 False）</td>
</tr>
<tr>
<td align="left">int_</td>
<td align="left">默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</td>
</tr>
<tr>
<td align="left">intc</td>
<td align="left">与 C 的 int 类型一样，一般是 int32 或 int 64</td>
</tr>
<tr>
<td align="left">intp</td>
<td align="left">用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</td>
</tr>
<tr>
<td align="left">int8</td>
<td align="left">字节（-128 to 127）</td>
</tr>
<tr>
<td align="left">int16</td>
<td align="left">整数（-32768 to 32767）</td>
</tr>
<tr>
<td align="left">int32</td>
<td align="left">整数（-2147483648 to 2147483647）</td>
</tr>
<tr>
<td align="left">int64</td>
<td align="left">整数（-9223372036854775808 to 9223372036854775807）</td>
</tr>
<tr>
<td align="left">uint8</td>
<td align="left">无符号整数（0 to 255）</td>
</tr>
<tr>
<td align="left">uint16</td>
<td align="left">无符号整数（0 to 65535）</td>
</tr>
<tr>
<td align="left">uint32</td>
<td align="left">无符号整数（0 to 4294967295）</td>
</tr>
<tr>
<td align="left">uint64</td>
<td align="left">无符号整数（0 to 18446744073709551615）</td>
</tr>
<tr>
<td align="left">float_</td>
<td align="left">float64 类型的简写</td>
</tr>
<tr>
<td align="left">float16</td>
<td align="left">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td>
</tr>
<tr>
<td align="left">float32</td>
<td align="left">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td>
</tr>
<tr>
<td align="left">float64</td>
<td align="left">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td>
</tr>
<tr>
<td align="left">complex_</td>
<td align="left">complex128 类型的简写，即 128 位复数</td>
</tr>
<tr>
<td align="left">complex64</td>
<td align="left">复数，表示双 32 位浮点数（实数部分和虚数部分）</td>
</tr>
<tr>
<td align="left">complex128</td>
<td align="left">复数，表示双 64 位浮点数（实数部分和虚数部分）</td>
</tr>
</tbody></table>
<p>numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。</p>
<p>可以用简写表示，例如‘s20’表示20位字符串，’i4’表示int32</p>
<ul>
<li><p>结构化化数据类型</p>
<p>数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：</p>
<ul>
<li>数据的类型（整数，浮点数或者 Python 对象）</li>
<li>数据的大小（例如， 整数使用多少个字节存储）</li>
<li>数据的字节顺序（小端法或大端法）</li>
<li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li>
<li>如果数据类型是子数组，它的形状和数据类型</li>
</ul>
<p>字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</p>
<p>dtype 对象是使用以下语法构造的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.dtype(object, align, copy)</span><br></pre></td></tr></table></figure>

<ul>
<li>object - 要转换为的数据类型对象</li>
<li>align - 如果为 true，填充字段使其类似 C 的结构体。</li>
<li>copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</li>
</ul>
</li>
</ul>
<h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><h3 id="numpy-empty"><a href="#numpy-empty" class="headerlink" title="numpy.empty"></a>numpy.empty</h3><p>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.empty(shape, dtype &#x3D; float, order &#x3D; &#39;C&#39;)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">shape</td>
<td align="left">数组形状</td>
</tr>
<tr>
<td align="left">dtype</td>
<td align="left">数据类型，可选</td>
</tr>
<tr>
<td align="left">order</td>
<td align="left">有”C”和”F”两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。</td>
</tr>
</tbody></table>
<p>下面是一个创建空数组的实例：</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>import numpy as np  x = np.empty([3,2], dtype = int)  print (x)</p>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[ 6917529027641081856  5764616291768666155]</span><br><span class="line"> [ 6917529027641081859 -5764598754299804209]</span><br><span class="line"> [          4497473538      844429428932120]]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> − 数组元素为随机值，因为它们未初始化。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/10/06/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%A5%E9%97%A8/" data-id="ckh2n5q4400004ou31sj7gzio" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-二进制数获取每一位" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/19/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%80%E4%BD%8D/" class="article-date">
  <time datetime="2020-09-19T01:12:27.000Z" itemprop="datePublished">2020-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/19/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%80%E4%BD%8D/">二进制数获取每一位</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/09/19/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%80%E4%BD%8D/" data-id="ckfbszupo0000v4u3bekwbq61" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-小学期01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/12/%E5%B0%8F%E5%AD%A6%E6%9C%9F01/" class="article-date">
  <time datetime="2020-09-12T12:15:38.000Z" itemprop="datePublished">2020-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/12/%E5%B0%8F%E5%AD%A6%E6%9C%9F01/">小学期01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="router跳转"><a href="#router跳转" class="headerlink" title="router跳转"></a>router跳转</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如</span><br><span class="line">在path 键对中填写需要跳转的路由</span><br><span class="line">this.$router.push(&#123; path: &quot;&#x2F;videoList&quot; &#125;);</span><br></pre></td></tr></table></figure>

<p>也可以通过路由传参，有三个基本方法</p>
<h5 id="方案一：直接通过参数传参"><a href="#方案一：直接通过参数传参" class="headerlink" title="方案一：直接通过参数传参"></a>方案一：直接通过参数传参</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; path: &quot;&#x2F;videoList&quot;&#x2F;$&#123;id&#125; &#125;);</span><br></pre></td></tr></table></figure>

<p>需要对应的路由配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path： &#39;&#x2F;videoList&#x2F;：vid&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方案二：通过params传参"><a href="#方案二：通过params传参" class="headerlink" title="方案二：通过params传参"></a>方案二：通过params传参</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jumpToVideoPlay(index) &#123;</span><br><span class="line">this.$router.push(&#123; path: &#39;&#x2F;videoplay&#39;, params: &#123; url:             &#39;http:&#x2F;&#x2F;10.136.215.124:1234&#x2F;&#39;+this.videoList[index].Path+&#39;&#x2F;&#39;+this.videoList[index].VideoName+&#39;.&#39;+&#39;mp4&#39;&#125;&#125;);       </span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>通过this.$router.params.url调用</p>
<h5 id="方案三：通过query传参"><a href="#方案三：通过query传参" class="headerlink" title="方案三：通过query传参"></a>方案三：通过query传参</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jumpToVideoPlay(index) &#123;</span><br><span class="line">this.$router.push(&#123; path: &#39;&#x2F;videoplay&#39;, query: &#123; url:             &#39;http:&#x2F;&#x2F;10.136.215.124:1234&#x2F;&#39;+this.videoList[index].Path+&#39;&#x2F;&#39;+this.videoList[index].VideoName+&#39;.&#39;+&#39;mp4&#39;&#125;&#125;);       </span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>通过this.$router.query.url调用</p>
<h3 id="第一次迭代回顾"><a href="#第一次迭代回顾" class="headerlink" title="第一次迭代回顾"></a>第一次迭代回顾</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/09/12/%E5%B0%8F%E5%AD%A6%E6%9C%9F01/" data-id="ckf0o1mtd0001jku34ebp7s8v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue的生命周期" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/08/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="article-date">
  <time datetime="2020-09-08T06:14:18.000Z" itemprop="datePublished">2020-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/08/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Vue的生命周期</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h1><p><strong>一、vue的生命周期是什么</strong></p>
<p>  vue每个组件都是独立的，每个组件都有一个属于它的生命周期，从一个组件<strong>创建、数据初始化、挂载、更新、销毁</strong>，这就是一个组件所谓的生命周期。在组件中具体的方法有:</p>
<p>  beforeCreate</p>
<p>  created</p>
<p>  beforeMount</p>
<p>  mounted</p>
<p>  (</p>
<p>​     beforeUpdate</p>
<p>​     updated</p>
<p>   )</p>
<p>  beforeDestroy</p>
<p>  destroyed</p>
<p>  对应的中文就如其字面意思，英文不好的童鞋可以有道翻翻</p>
<p>  好了，这里要上图啦<del>~</del></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13119812-eaf493b1b2050a93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720/format/webp" alt="img"></p>
<p><strong>二、vue生命周期的在项目中的执行顺序</strong></p>
<p>…</p>
<p>data () {</p>
<p>  return {</p>
<p>  rendered: false,</p>
<p>}</p>
<p>}</p>
<p>…</p>
<p>1.beforeCeate(){</p>
<p>  console.log(this.rendered);  // undefined </p>
<p><img src="https://upload-images.jianshu.io/upload_images/13119812-5727fdabcfab0a7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/530/format/webp" alt="img"></p>
<p>}</p>
<p>2.created() {</p>
<p>  console.log(this.$el);//undefined</p>
<p>   console.log(this.rendered); // false</p>
<p>}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13119812-6d94d9db2f52a7c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/532/format/webp" alt="img"></p>
<p>3.beforeMount() {</p>
<p>  console.log(this.$el)；//undefined</p>
<p>}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13119812-9c382de4ef59b6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/520/format/webp" alt="img"></p>
<p>4.mounted() {</p>
<p>  console.log(this.$el);</p>
<p>}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13119812-095add76ef7c1953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/536/format/webp" alt="img"></p>
<p>5.beforeDestroty(){</p>
<p>  console.log(this.$el);</p>
<p>  console.log(this.rendered); </p>
<p>}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13119812-4980a396e64eee6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/535/format/webp" alt="img"></p>
<p>6.destroyed() {</p>
<p>  console.log(this.$el);</p>
<p>  console.log(this.rendered);</p>
<p>}</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13119812-c8feee355871be70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/538/format/webp" alt="img"></p>
<p><strong>三、vue中内置的方法 属性和vue生命周期的运行顺序（methods、computed、data、watch、props)</strong></p>
<p>  从第一二点可知道data的初始化是在created时已经完成数据观测(data observer)，并且诸如methods、computed属性 props等已经初始化；那问题来了，</p>
<p>data props computed watch methods他们之间的生成顺序是什么呢？</p>
<p>根据翻看vue源码可知：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/13119812-551024dfb2fe9961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/477/format/webp" alt="img"></p>
<p><strong>props =&gt; methods =&gt;data =&gt; computed =&gt; watch</strong>; 懂了没 </p>
<p><strong>四、自己构造的方法与vue生命周期的运行顺序 如show这些</strong></p>
<p>  往往我们在开发项目时都经常用到 $refs 来直接访问子组件的方法，但是这样调用的时候可能会导致数据的延迟滞后的问题，则会出现bug。</p>
<p>解决方法则是推荐采取<strong>异步回调</strong>的方法，然后传参进去，严格遵守vue的生命周期就可以解决 推荐 es6 的promise。</p>
<p>示例代码：</p>
<p>handleAsync () {</p>
<p>  return new Promise(resolve=&gt;{</p>
<p>​    const res=””;</p>
<p>​    resolve(res)</p>
<p>})</p>
<p>}</p>
<p>…</p>
<p>async handleShow() {</p>
<p>  await this.handleAsync().then(res=&gt;{</p>
<p>  this.$refs.child.show(res);</p>
<p>})</p>
<p>}</p>
<p>…</p>
<p><strong>五、总结</strong></p>
<p>  vue 的生命周期，总得来说就是实例的创建和销毁这段时间的一个机制吧。也是vue框架的数据间的交互通信。其实现在看来也没那么难，但是vue的源码实现这一套机制那是难得一逼，涉及到复杂的算法如<strong>diff算法</strong>，有兴趣的童鞋可以去深入了解一下。喜欢的童鞋点个赞 啊哈哈，又来骗赞啦</p>
<p>作者：CalvinXie<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/410b6099be69">https://www.jianshu.com/p/410b6099be69</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/09/08/Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" data-id="ckf0nzwdv0000jku30lrfa1ha" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js基础-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/23/js%E5%9F%BA%E7%A1%80-1/" class="article-date">
  <time datetime="2020-08-23T01:13:35.000Z" itemprop="datePublished">2020-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/23/js%E5%9F%BA%E7%A1%80-1/">js基础(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>对象是某个引用类型的实例，新对象是使用<code>new</code>操作符后跟一个构造函数来创建的。构造函数本身是一个函数，只不过该函数是为创建对象的目的而定义的。</p>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h3><p>大多数引用类型值都是Object类型的实例</p>
<p><strong>创建：</strong></p>
<ul>
<li>new操作符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name=<span class="string">&quot;ly&quot;</span>;</span><br><span class="line">person.age=<span class="number">22</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象字面量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    name:<span class="string">&quot;ly&quot;</span>,</span><br><span class="line">    age:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>在适用对象字面量时，属性名也可以使用字符串（用引号包起来）。<br>也可以使用空花括号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;&#125;；</span><br><span class="line">person.name=<span class="string">&quot;ly&quot;</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>一般来说，访问对象属性时使用的都是点表示法，不过也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该讲要访问的属性以字符串的形式放在方括号中，例如 ：<code>person[&quot;name&quot;]</code>。<br>从功能上看，这两种访问方式没有任何区别，但方括号的优点是可以通过变量来访问属性：<code>var key=&quot;name&quot;; person[key]&quot;</code>。<br>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字，也可以使用方括号：<code>person[&quot;first name&quot;]</code></p>
<h3 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h3><p>数组是一个按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意的数据类型。数组用<code>[]</code>表示，元素之间用<code>,</code>分隔，并且ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长。</p>
<p><strong>创建：</strong><br>有两种基本方式：</p>
<ul>
<li>使用Array构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//创建了一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//创建了数组[1,2,3]</span></span><br><span class="line"><span class="keyword">var</span> colors=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);<span class="comment">//创建了一个长度为20的数组</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>也可以省略<code>new</code>，结果相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=<span class="built_in">Array</span>();<span class="comment">//创建了一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr=<span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//创建了数组[1,2,3]</span></span><br><span class="line"><span class="keyword">var</span> colors=<span class="built_in">Array</span>(<span class="number">20</span>);<span class="comment">//创建了一个长度为20的数组</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字面量<br>数组的字面量有一对包含数组项的方括号表示，多个项数之间由<code>,</code>隔开</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result=[];<span class="comment">//创建了一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="comment">//创建了数组[1,2,3]</span></span><br><span class="line"><span class="keyword">var</span> color=[<span class="number">2</span>,<span class="number">3</span>,];<span class="comment">//最好不要这样写，因为这样可能会创建一个2项或3项的数组</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>在例子的第三个中，在IE8及之前的版本中，color会是一个2，3，undefined的数组，在其他浏览器中，color是一个包含2项的数组。</p>
<p>数组的元素可以通过索引来访问和设置。注意，索引的开始值为0。</p>
<p><strong>检测数组</strong><br>判断某个对象是不是数组。</p>
<ul>
<li>instanceof<br>对于一个网页，过着一个全局作用域而言，使用instanceof操作符就可以得到结果：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>但他的问题在于，他假定只有一个全局执行环境。如果网页包含多个框架，那实际上就有多个不同的全局执行环境从而存在多个版本的Array构造函数，如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原生创建的数组分别具有和各自的不同的构造函数。<br>为解决这个问题，ECMAScript 5新增了Array.isArray()方法。</p>
<ul>
<li>Array.isArray()<br>确定某个值到底是不是数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value)&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42853241/article/details/93141194"><strong>数组的方法</strong>(可点击）</a></p>
<h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><p>Date类型使用字UTC（国际协调时间）1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够准确精确到1970年1月1日之前或之后的100 000 000年。</p>
<p><strong>创建：</strong><br>使用new操作符和Date构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在不传参的情况下，new Date()自动获取当前的日期和时间。<br>如果想要根据特定的日期和时间创建日期对象，必须传入便是该日期的毫秒数（即从1970年1月1日午夜起至该日期止经过的毫秒数。</p>
<blockquote>
<p>ECMAScript提供了两个方法获得毫秒数：Date.parse()，Date.UTC()<br>Date.parse()：传入日期的字符串参数得到毫秒数<br>Date.UTC()：参数是年份、月份（基于0）、月中的天数、小时数、分钟、秒及毫秒（前两项必需）<br>var date1=new Date(Date.parse(“2005,1,1”));<br>var date2=new Date(Date.UTC(2005,0,1));<br>这两个方法等价于new Date(“2005,1,1”);<br>new Date(2005,0,1);<br>他们虽然省略了方法的调用，但是执行时会在后台调用方法。</p>
</blockquote>
<p>Date.now()：返回表示调用这个方法时的日期和时间的毫秒数</p>
<p><strong>方法：</strong></p>
<ul>
<li>toLocaleString()：按照与浏览器设置的地区相适应的格式返回日期和时间，应该会包括AM、PM（不包含时区信息）</li>
<li>toString()：返回带有时区信息的日期和时间</li>
<li>valueOf()：返回日期的毫秒表示</li>
<li>toDateString()：以特定于实现的格式显示星期几、月、日和年</li>
<li>toTimeString()：以特定于实现的格式显示时、分、秒和时区</li>
<li>toLocaleDateString()：以特定于地区的格式显示星期几、月、日和年</li>
<li>toLocaleTimeString()：以特定于实现的格式显示时、分、秒</li>
<li>toUTCString()：以特定于实现的格式完整的UTC日期</li>
</ul>
<blockquote>
<p>以上方法因浏览器而异</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> date=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(date.toLocaleString());</span><br><span class="line">    <span class="built_in">console</span>.log(date.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(date.valueOf());</span><br><span class="line">    <span class="built_in">console</span>.log(date.toDateString());</span><br><span class="line">    <span class="built_in">console</span>.log(date.toTimeString());</span><br><span class="line">    <span class="built_in">console</span>.log(date.toLocaleDateString());</span><br><span class="line">    <span class="built_in">console</span>.log(date.toLocaleTimeString());</span><br><span class="line">    <span class="built_in">console</span>.log(date.toUTCString());</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20191106184159174.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191106185024669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODUzMjQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>除此以外还有很多方法：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/jsref/jsref_obj_date.asp">点击</a></p>
<blockquote>
<p>var n=+new Date()也可以得到毫秒值</p>
</blockquote>
<h3 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h3><p>ECMAScript通过RegExp类型来支持正则表达式。</p>
<p><strong>①创建：</strong></p>
<ul>
<li>字面量创建</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>其中的pattern部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。<br>每个正则表达式都带有一个或多个标志位flags，用以标明正则表达式的行为。</p>
<p><strong>标志：</strong></p>
<ul>
<li>g：表示全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止</li>
<li>i：表示不区分大小写模式</li>
<li>m：表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> reg=<span class="regexp">/at/g</span>;   <span class="comment">//全局匹配at</span></span><br><span class="line">    <span class="keyword">var</span> reg2=<span class="regexp">/[bc]at/i</span>;  <span class="comment">//匹配第一个bat或cat，不区分大小写</span></span><br><span class="line">    <span class="keyword">var</span> reg3=<span class="regexp">/.at/gi</span>;    <span class="comment">//匹配所有以at结尾的3个字符的组合，不区分大小写</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>正则表达式的元字符</strong>：<code>( [ &#123; \ ^ $ | ) ? * + . ] &#125;</code>，如果想要匹配的字符串中包含这些字符，就必须对他们进行转义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> reg1=<span class="regexp">/[bc]at/i</span>;   <span class="comment">//匹配第一个bat或cat，不区分大小写</span></span><br><span class="line">    <span class="keyword">var</span> reg2=<span class="regexp">/\[bc\]at/i</span>;<span class="comment">//匹配第一个[bc]at，不区分大小写</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数创建<br>接收两个参数，一个是要匹配的字符串模式，一个是可选的标志字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;[bc]at&quot;</span>,<span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> reg1=<span class="regexp">/[bc]at/i</span>;   </span><br><span class="line"><span class="comment">//匹配第一个bat或cat，不区分大小写</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：在构造函数创建的方法中，参数是字符串，所以元字符要双重转义</p>
<p>使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript 3 中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。ECMAScript 5规定，使用字面量要和构造函数一样，每次都创建新的实例。</p>
<p><strong>②实例属性</strong></p>
<ul>
<li>global：布尔值，表示是否设置了g标志</li>
<li>ignoreCase：布尔值，表示是否设置了i标志</li>
<li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起</li>
<li>multiline：布尔值，表示是否设置了m标志</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回</li>
</ul>
<p><strong>③实例方法</strong></p>
<ul>
<li>exec()<br>专门为捕获组而设计的。接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项的信息的数组；或者在没有匹配项的情况下返回null。<br>返回的数组虽然是Array的实例，但包含两个额外的属性：index,input<br>index表示匹配项在字符串中的位置；input表示应用正则表达式的字符串。<br>在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果没有捕获组，则该数组只包含一项）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test=<span class="string">&quot;mom and dad and baby&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/mom( and dad( and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">var</span> matches=reg.exec(test);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input);<span class="comment">//&quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);   <span class="comment">//&quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);   <span class="comment">//&quot; and dad and baby&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);   <span class="comment">//&quot; and baby&quot;</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<ul>
<li>test()<br>目标字符串与某个模式是否匹配。返回结果为boolean值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text=<span class="string">&quot;000-00-0000&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg=<span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span>(reg.test(text))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<ul>
<li>toString()、toLocaleString()<br>返回正则表达式的字面量</li>
<li>valueOf()<br>返回正则表达式本身</li>
</ul>
<h3 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h3><p>函数实际上是对象。可以封装一段特定功能的代码。每个函数都是Function类型的实例，具有属性和方法。函数名是一个指向函数对象的指针。</p>
<p>函数名仅仅是只想函数对象的指针，因此函数名和包含对象指针的其他变量没有什么不同，所以，一个函数可以有多个名字。</p>
<p><strong>①创建</strong></p>
<ul>
<li>函数声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数表达式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum=<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数<br>可以传入多个参数，但最后一个参数会作为函数体。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum =<span class="keyword">new</span> <span class="built_in">Function</span> (<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;return a+b&quot;</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>②没有重载</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=sum(<span class="number">100</span>);<span class="comment">//300</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>后面的函数覆盖了前面的函数</p>
<p><strong>②函数声明和函数表达式</strong></p>
<p>解析器在向执行环境中加载数据时，会率先读取函数声明，并使其在任何代码之前可用（可以访问）；而函数表达式，则必须等到解析器执行到他所在的代码行，才会真正被解释执行。也就是说，函数声明存在函数声明提升问题。</p>
<p><strong>③作为值的函数</strong><br>可以传参，可以返回</p>
<p>示例：斐波那契数列<br>函数作为返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getFib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n===<span class="number">1</span>||n===<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getFib(n<span class="number">-1</span>)+getFib(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(getFib(<span class="number">7</span>));</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>示例：sort()比较<br>函数作为参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">         <span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="number">13</span>, <span class="number">24</span>, <span class="number">51</span>, <span class="number">3</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(arr.sort(compare)); <span class="comment">// [3, 13, 24, 51]</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p><strong>④函数内部属性</strong></p>
<ul>
<li>arguments<br>类数组对象，包含着传入函数中的所有参数。（获取实参）<br>这个对象有一个callee属性：该属性是一个指针，指向拥有这个arguments对象的函数。<br>示例：阶乘函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getF</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n*getF(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(getF(<span class="number">7</span>));</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>以上代码，这个函数的执行与函数名紧紧的绑在一起。为了解决这个问题，可以使用callee</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getF</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n*<span class="built_in">arguments</span>.callee(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(getF(<span class="number">7</span>));</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<ul>
<li>this<br>引用的是函数执行的环境对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color=<span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">color</span>:<span class="string">&quot;blue&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">col</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">&#125;</span><br><span class="line">col();    <span class="comment">//&quot;red&quot;,此时的this是window</span></span><br><span class="line">o.col=col;</span><br><span class="line">o.col();  <span class="comment">//&quot;blue&quot;，此时的this是o对象</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<ul>
<li>caller<br>调用当前函数的引用，如果是在全局作用域中调用当前函数，它的值为null</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(inner.caller);  <span class="comment">//指向outer()</span></span><br><span class="line">&#125;</span><br><span class="line">outer();   </span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><strong>⑤函数属性和方法</strong></p>
<ul>
<li>属性</li>
</ul>
<ol>
<li>length：表示函数希望接收的命名参数的个数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum.length);   <span class="comment">//2</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<ol>
<li>prototype：保存引用类型所有实例方法的真正所在。在ECMAScript 5中，prototype属性是不可枚举的。</li>
</ol>
<ul>
<li>方法<br>每个函数都有两个非继承而来的方法：call()、apply()。这两个方法的作用都是在特定过的作用域中调用函数，实际上等于设置函数体内的this。</li>
</ul>
<ol>
<li>apply()：接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组，第二个参数可以是Array实例，也可以是arguments对象。</li>
<li>call()：和apply()的作用相同，区别在于接收参数的方式不同。对于call()而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//等价</span></span><br><span class="line">    <span class="comment">//return sum.apply(this,[a,b]);</span></span><br><span class="line">    <span class="comment">//return sum.call(this,a,b);</span></span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>call、apply真正强大的地方是能够扩充函数赖以运行的作用域。看以下示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color=<span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">color</span>:<span class="string">&quot;blue&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">col</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">&#125;</span><br><span class="line">col();    <span class="comment">//&quot;red&quot;</span></span><br><span class="line">col.call(<span class="built_in">this</span>);   <span class="comment">//&quot;red&quot;</span></span><br><span class="line">col.call(<span class="built_in">window</span>);  <span class="comment">//&quot;red&quot;</span></span><br><span class="line">col.call(o);    <span class="comment">//&quot;blue&quot;</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<ol>
<li>bind()：ECMAScript 5还定义了一个方法bind()。这个方法会创建一个函数的实例，其this值会绑定到传给bind函数的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color=<span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> o=&#123;<span class="attr">color</span>:<span class="string">&quot;blue&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">col</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn=col.bind(o);    </span><br><span class="line">fn();     <span class="comment">//&quot;blue&quot;</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<ol>
<li>每个函数继承的toString()、toLocaleString()和valueOf()方法始终返回函数的代码，其结果因浏览器而异</li>
</ol>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>ECMAScript提供了3个特殊的引用类型：Boolean、String、Number。他们与引用类型相似，但也具有各自的特殊行为。</p>
<p>实际上，每当读取到一个基本类型的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用方法操作这些数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;ly is an apple&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s1=str.substring(<span class="number">2</span>);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>当第二行代码访问str时，访问过程处于一种读取模式，而在读取模式中访问字符串时，后台都会自动完成下列处理：<br>1.创建String类型的一个实例<br>2.在实例上调用指定方法<br>3.销毁这个实例</p>
<p>引用类型和基本包装类型的区别：对象的生存周期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时给类型值添加属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;some string&quot;</span>;</span><br><span class="line">str.color=<span class="string">&quot;red&quot;</span>;</span><br><span class="line">alert(str.color); <span class="comment">//undefined</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>对基本包装类型的实例调用 typeof会返回<code>&quot;object&quot;</code>，而且所有的基本包装类型对象在转换为布尔类型的值都为<code>true</code>。</p>
<p><strong>①Boolean类型</strong><br>Boolean类型是与布尔值对应的引用类型。</p>
<p>创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>valueOf()：返回基本类型值true或false<br>toString()：返回字符串”true”或”false”</p>
<p>要注意的是在布尔表达式中使用Boolean对象<br>布尔表达式中的所有对象都会被转换为true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fobj=<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> result=fobj&amp;&amp;<span class="literal">true</span>;</span><br><span class="line">alert(result);   <span class="comment">//true</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">alert(<span class="keyword">typeof</span> fobj);    <span class="comment">//object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="literal">false</span>);    <span class="comment">//boolean</span></span><br><span class="line">alert(fobj <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>②Number类型</strong>、</p>
<p>Number类型是与数字值对应的引用类型。</p>
<p>创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>valueOf()：返回对象表示的基本类型的值<br>toString()、toLocaleString()：返回字符串形式的数值，toString()可以传参表示进制</p>
<p>方法：</p>
<ul>
<li>toFixed()：按照指定的小数位返回数值的字符串格式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line">alert(num.toFixed(<span class="number">2</span>));    <span class="comment">//&quot;10.00&quot;</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>toExponential()：返回以指数表示法表示的数值的字符串格式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line">alert(num.toExponential(<span class="number">1</span>));   <span class="comment">//&quot;1.0e+1&quot;</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>toPrecision()：返回某个数值的最合适的格式。可能返回固定大小格式，也可能返回指数格式。接收一个参数，表示所有数字的位数，不包括指数部分</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">99</span>;</span><br><span class="line">alert(num.toPrecision(<span class="number">1</span>));   <span class="comment">//&quot;1e+2&quot;</span></span><br><span class="line">alert(num.toPrecision(<span class="number">2</span>));   <span class="comment">//&quot;99&quot;</span></span><br><span class="line">alert(num.toPrecision(<span class="number">3</span>));    <span class="comment">//&quot;99.0&quot;</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>实际上，toPrecision()会根据要处理的数值决定到底是调用toFixed()还是toExponential()。</p>
<p><strong>③String类型</strong></p>
<p>String类型是与字符串对应的引用类型。</p>
<p>创建：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>valueOf()、toString()、toLocaleString()：返回对象表示的基本字符串值</p>
<ul>
<li>length：String类型的每个实例都有一个length属性，表示字符串中包含多少个字符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">alert(str.length);   <span class="comment">//11</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42853241/article/details/93517898"><strong>字符串的方法</strong>（可点击）</a></p>
<h3 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><p>ECMA-262对内置对象的定义是：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。</p>
<p>内置对象：Object、Array、String、Global、Math、Date等等…</p>
<p><strong>①Global对象</strong></p>
<p>不属于任何其他对象的属性和方法，最终都是他的属性和方法。事实上，没有全局变量和全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。</p>
<p>之前学习的isNaN()、parseInt()等等，都是Global对象的方法，除此之外，还有一些其他的方法：</p>
<ul>
<li>URI编码方法</li>
</ul>
<ol>
<li>encodeURI()、encodeURIComponent()<br>可以对URI进行编码，利用特殊的UTF-8编码代替所有无效的字符（有效的URI中不能包含某些字符，例如空格）。<br><code>encodeURI()</code>主要对于整个URI；<code>encodeURIComponent()</code>主要用于对URI中的某一段进行编码。它们的区别主要在于encodeURI不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问好和井号；而encodeURIComponent()则会对他发现的任何特殊字符进行编码。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri=<span class="string">&quot;https://blog.csdn.net/qq_42853241/article/details/85068177&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURI</span>(uri));</span><br><span class="line"><span class="comment">//&quot;https://blog.csdn.net/qq_42853241/article/details/85068177&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(uri));</span><br><span class="line"><span class="comment">//&quot;https%3A%2F%2Fblog.csdn.net%2Fqq_42853241%2Farticle%2Fdetails%2F85068177&quot;</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<ol>
<li>decodeURI()、decodeURIComponent()<br>与上面两个方法对应。decodeURI()只能对使用encodeURI()替换的字符进行解码；decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri=<span class="string">&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURI</span>(uri));</span><br><span class="line"><span class="comment">//&quot;http%3A%2F%2Fwww.wrox.com%2Fillegal value.htm%23start&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">decodeURIComponent</span>(uri));</span><br><span class="line"><span class="comment">//&quot;http://www.wrox.com/illegal value.htm#start&quot;</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>URI方法用于替代已经被ECMA-262第3版废弃的escape()和unescape()方法<br>URI方法可以编码所有的Unicode字符，而原来的方法只能编码ASCII字符</p>
</blockquote>
<ul>
<li>eval()<br>eval()方法就像是一个完整的ECMAScript解析器，只接受一个参数，即要执行的ECMAScript字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;alert(&#x27;hi&#x27;)&quot;</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>eval()将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。<br>通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;alert(msg)&quot;</span>);  <span class="comment">//&quot;hello world&quot;</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>同样的，我们可以在eval()中定义一个函数或者变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function sayHi()&#123;</span></span><br><span class="line"><span class="string">    alert(&#x27;hi&#x27;);</span></span><br><span class="line"><span class="string">&#125;&quot;</span>);</span><br><span class="line">sayHi(); <span class="comment">//&#x27;hi&#x27;</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var msg=&#x27;hello world&#x27;;&quot;</span>);</span><br><span class="line">alert(msg);  <span class="comment">//&#x27;hello world&#x27;</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，他们被包含在一个字符串中，只在eval()被执行的时候创建.<br>严格模式下，在外部访问不到eval()中创建的任何变量或函数，因此，前面的一个例子在严格模式下会导致错误。<br>严格模式下，为eval赋值也会导致错误<code>&quot;use strict&quot;; eval=&#39;hi&#39;;</code>报错</p>
<ul>
<li>Global对象的属性<br>Global对象还包含一些属性：undefined、NaN、Infinity都是Global对象的属性，此外，所有的原生引用类型的构造函数，像Object和Function，也都是Global对象的属性</li>
<li>window对象<br>ECMAScript没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为window对象的属性。<br>另一种取得Global对象的方法是使用以下代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">global</span>=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>②    Math对象</strong></p>
<p>Math——为保存数学公式和信息提供的公共位置。</p>
<p>与我们在JS直接编写的计算功能相比，Math对象提供的计算功能执行起来要快的多。</p>
<ul>
<li>Math对象的属性<br>语法：Math.***，例如：Math.E<br><img src="https://img-blog.csdnimg.cn/2019112116092630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODUzMjQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>min()、max()<br>用于确定一组数值中的最大值和最小值，可以接受任意多个数值参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min=<span class="built_in">Math</span>.min(<span class="number">3</span>,<span class="number">54</span>,<span class="number">32</span>,<span class="number">16</span>);</span><br><span class="line"><span class="built_in">console</span>.log(min);<span class="comment">//3</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>要找到数组中的最大或最小值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">44</span>,<span class="number">23</span>,<span class="number">87</span>,<span class="number">14</span>,<span class="number">87</span>];</span><br><span class="line">    <span class="keyword">var</span> result=<span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,arr);</span><br><span class="line">    <span class="built_in">console</span>.log(result);<span class="comment">//87</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>舍入方法<br><code>floor()</code>、<code>ceil()</code>、<code>round()</code><br>Math.ceil()：向上舍入<br>Math.floor()：向下舍入<br>Math.round()：四舍五入</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.1</span>));  <span class="comment">//26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.6</span>));  <span class="comment">//26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">25.9</span>));  <span class="comment">//26</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.1</span>));  <span class="comment">//25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.6</span>));  <span class="comment">//25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>));  <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.1</span>));  <span class="comment">//25</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.5</span>));  <span class="comment">//26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">25.9</span>));  <span class="comment">//26</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<ul>
<li>random()<br>返回大于等于0小于1的一个随机数（返回的是小数值）<br>语法：<code>值=Math.floor(Math.random()*可能值的总数+第一个可能的值)</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="number">-10</span>中的随机整数</span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">10</span>+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="number">-10</span>中的一个随机整数</span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">9</span>+<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yuunawl.github.io/2020/08/23/js%E5%9F%BA%E7%A1%80-1/" data-id="ckes3psvm0000i0u3g5rj0ff1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/11/%E9%9F%B3%E9%9F%B3%E3%81%AE%E6%9D%82%E8%B0%88/">音音の杂谈</a>
          </li>
        
          <li>
            <a href="/2020/12/09/%E9%9F%B3%E9%9F%B3%E3%81%AE%E9%9D%A2%E7%BB%8F/">音音の面经</a>
          </li>
        
          <li>
            <a href="/2020/12/08/%E5%88%9B%E4%B9%8B%E8%BD%A8%E8%BF%B9%E7%AE%80%E8%AF%84/">音音の游戏简评——创之轨迹</a>
          </li>
        
          <li>
            <a href="/2020/12/08/%E9%9F%B3%E9%9F%B3%E3%81%AEFF14-5-4%E6%8A%80%E6%94%B9/">音音のFF14---5.4技改</a>
          </li>
        
          <li>
            <a href="/2020/12/07/%E9%9F%B3%E9%9F%B3%E3%81%AE%E5%BA%A7%E5%8F%B3%E9%93%AD/">音音の座右铭</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>